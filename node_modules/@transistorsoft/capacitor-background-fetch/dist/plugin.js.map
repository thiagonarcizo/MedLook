{"version":3,"file":"plugin.js","sources":["esm/index.js"],"sourcesContent":["import { registerPlugin } from '@capacitor/core';\nconst EVENT_FETCH = \"fetch\";\nconst TAG = \"BackgroundFetch\";\nconst STATUS_RESTRICTED = 0;\nconst STATUS_DENIED = 1;\nconst STATUS_AVAILABLE = 2;\nconst NETWORK_TYPE_NONE = 0;\nconst NETWORK_TYPE_ANY = 1;\nconst NETWORK_TYPE_UNMETERED = 2;\nconst NETWORK_TYPE_NOT_ROAMING = 3;\nconst NETWORK_TYPE_CELLULAR = 4;\nconst NativeModule = registerPlugin('BackgroundFetch');\nlet subscriber = null;\n/**\n* BackgroundFetch is a module to receive periodic callbacks (min every 15 min) while your app is running in the background or terminated.\n*\n* ```javascript\n* import {BackgroundFetch} from '@transistorsoft/capacitor-background-fetch';\n*\n* class HomePage {\n*\n*   // Initialize in ngAfterContentInit\n*   // [WARNING] DO NOT use ionViewWillEnter, as that method won't run when app is launched in background.\n*   ngAfterContentInit() {\n*     this.initBackgroundFetch();\n*   }\n*\n*   async initBackgroundFetch() {\n*     const status = await BackgroundFetch.configure({\n*       minimumFetchInterval: 15\n*     }, async (taskId) => {  // <---------------- Event handler.\n*       console.log('[BackgroundFetch] EVENT:', taskId);\n*       // Perform your work in an awaited Promise\n*       const result = await this.performYourWorkHere();\n*       console.log('[BackgroundFetch] work complete:', result);\n*       // [REQUIRED] Signal to the OS that your work is complete.\n*       BackgroundFetch.finish(taskId);\n*     }, async (taskId) => {  // <---------------- Event timeout handler\n*       // The OS has signalled that your remaining background-time has expired.\n*       // You must immediately complete your work and signal #finish.\n*       console.log('[BackgroundFetch] TIMEOUT:', taskId);\n*       // [REQUIRED] Signal to the OS that your work is complete.\n*       BackgroundFetch.finish(taskId);\n*     });\n*\n*     // Checking BackgroundFetch status:\n*     if (status !== BackgroundFetch.STATUS_AVAILABLE) {\n*       // Uh-oh:  we have a problem:\n*       if (status === BackgroundFetch.STATUS_DENIED) {\n*         alert('The user explicitly disabled background behavior for this app or for the whole system.');\n*       } else if (status === BackgroundFetch.STATUS_RESTRICTED) {\n*         alert('Background updates are unavailable and the user cannot enable them again.')\n*       }\n*     }\n*   }\n*\n*   // Simulate a long-running task (eg:  an HTTP request)\n*   async performYourWorkHere() {\n*     return new Promise((resolve, reject) => {\n*       setTimeout(() => {\n*         resolve(true);\n*       }, 5000);\n*     });\n*   }\n* }\n* ```\n* ## iOS\n* - There is **no way** to increase the rate which a fetch-event occurs and this plugin sets the rate to the most frequent possible &mdash; you will **never** receive an event faster than **15 minutes**.  The operating-system will automatically throttle the rate the background-fetch events occur based upon usage patterns.  Eg: if user hasn't turned on their phone for a long period of time, fetch events will occur less frequently.\n* - [__`scheduleTask`__](#executing-custom-tasks) seems only to fire when the device is plugged into power.\n* - ⚠️ When your app is **terminated**, iOS *no longer fires events* &mdash; There is *no such thing* as **`stopOnTerminate: false`** for iOS.\n* - iOS can take *days* before Apple's machine-learning algorithm settles in and begins regularly firing events.  Do not sit staring at your logs waiting for an event to fire.  If your [*simulated events*](#debugging) work, that's all you need to know that everything is correctly configured.\n* - If the user doesn't open your *iOS* app for long periods of time, *iOS* will **stop firing events**.\n*\n* ## Android\n* - The Android plugin is capable of operating after app terminate (see API docs [[BackgroundFetchConfig.stopOnTerminate]], [[BackgroundFetchConfig.enableHeadless]]) but only by implementing your work with Java code.\n*/\nexport class BackgroundFetch {\n    /**\n    * Background fetch updates are unavailable and the user cannot enable them again. For example, this status can occur when parental controls are in effect for the current user.\n    */\n    static get STATUS_RESTRICTED() { return STATUS_RESTRICTED; }\n    /**\n    * The user explicitly disabled background behavior for this app or for the whole system.\n    */\n    static get STATUS_DENIED() { return STATUS_DENIED; }\n    /**\n    * Background fetch is available and enabled.\n    */\n    static get STATUS_AVAILABLE() { return STATUS_AVAILABLE; }\n    /**\n    * This job doesn't care about network constraints, either any or none.\n    */\n    static get NETWORK_TYPE_NONE() { return NETWORK_TYPE_NONE; }\n    /**\n    * This job requires network connectivity.\n    */\n    static get NETWORK_TYPE_ANY() { return NETWORK_TYPE_ANY; }\n    /**\n    * This job requires network connectivity that is a cellular network.\n    */\n    static get NETWORK_TYPE_CELLULAR() { return NETWORK_TYPE_CELLULAR; }\n    /**\n    * This job requires network connectivity that is unmetered.\n    */\n    static get NETWORK_TYPE_UNMETERED() { return NETWORK_TYPE_UNMETERED; }\n    /**\n    * This job requires network connectivity that is not roaming.\n    */\n    static get NETWORK_TYPE_NOT_ROAMING() { return NETWORK_TYPE_NOT_ROAMING; }\n    /**\n    * Initial configuration of BackgroundFetch, including config-options and Fetch-callback.  The [[start]] method will automatically be executed.\n    *\n    * ```javascript\n    *   async initBackgroundFetch() {\n    *     const status = await BackgroundFetch.configure({\n    *       minimumFetchInterval: 15\n    *     }, async (taskId) => {  // <---------------- Event handler.\n    *       console.log('[BackgroundFetch] EVENT:', taskId);\n    *       // Perform your work in an awaited Promise\n    *       const result = await this.performYourWorkHere();\n    *       console.log('[BackgroundFetch] work complete:', result);\n    *       // [REQUIRED] Signal to the OS that your work is complete.\n    *       BackgroundFetch.finish(taskId);\n    *     }, async (taskId) => {  // <---------------- Event timeout handler\n    *       // The OS has signalled that your remaining background-time has expired.\n    *       // You must immediately complete your work and signal #finish.\n    *       console.log('[BackgroundFetch] TIMEOUT:', taskId);\n    *       // [REQUIRED] Signal to the OS that your work is complete.\n    *       BackgroundFetch.finish(taskId);\n    *     });\n    *\n    *     // Checking BackgroundFetch status:\n    *     if (status !== BackgroundFetch.STATUS_AVAILABLE) {\n    *       // Uh-oh:  we have a problem:\n    *       if (status === BackgroundFetch.STATUS_DENIED) {\n    *         alert('The user explicitly disabled background behavior for this app or for the whole system.');\n    *       } else if (status === BackgroundFetch.STATUS_RESTRICTED) {\n    *         alert('Background updates are unavailable and the user cannot enable them again.')\n    *       }\n    *     }\n    *   }\n    *\n    *   // Simulate a long-running task (eg:  an HTTP request)\n    *   async performYourWorkHere() {\n    *     return new Promise((resolve, reject) => {\n    *       setTimeout(() => {\n    *         resolve(true);\n    *       }, 5000);\n    *     });\n    *   }\n    * }\n    * ```\n    */\n    static configure(config, onEvent, onTimeout) {\n        if (typeof (onEvent) !== 'function') {\n            throw \"BackgroundFetch requires an event callback at 2nd argument\";\n        }\n        if (typeof (onTimeout) !== 'function') {\n            console.warn(\"[BackgroundFetch] configure:  You did not provide a 3rd argument onTimeout callback.  This callback is a signal from the OS that your allowed background time is about to expire.  Use this callback to finish what you're doing and immediately call BackgroundFetch.finish(taskId)\");\n            onTimeout = (taskId) => {\n                console.warn('[BackgroundFetch] default onTimeout callback fired.  You should provide your own onTimeout callbcak to .configure(options, onEvent, onTimeout)');\n                BackgroundFetch.finish(taskId);\n            };\n        }\n        const myOnTimeout = onTimeout;\n        if (subscriber !== null) {\n            subscriber.remove();\n            subscriber = null;\n        }\n        subscriber = NativeModule.addListener(EVENT_FETCH, (event) => {\n            if (!event.timeout) {\n                onEvent(event.taskId);\n            }\n            else {\n                myOnTimeout(event.taskId);\n            }\n        });\n        config = config || {};\n        return new Promise((resolve, reject) => {\n            NativeModule.configure({ options: config }).then((result) => {\n                resolve(result.status);\n            }).catch((error) => {\n                console.warn(TAG, \"ERROR:\", error);\n                reject(error.message);\n            });\n        });\n    }\n    /**\n    * Execute a custom task in addition to the one initially provided to [[configure]].\n    * This event can be configured to either a \"ONE-SHOT\" or \"PERIODIC\" with [[TaskConfig.periodic]].\n    *\n    * ```javascript\n    * // You must ALWAYS first configure BackgroundFetch.\n    * const status = await BackgroundFetch.configure({\n    *   minimumFetchInterval: 15\n    * }, async (taskId) => {\n    *   console.log('[BackgroundFetch] EVENT', taskId);\n    *   if (taskId === 'my-custom-task') {\n    *     console.log('Handle your custom-task here');\n    *   } else {\n    *     console.log('This is the default, periodic fetch task');\n    *   }\n    *   // Always signal completion of your tasks.\n    *   BackgroundFetch.finish(taskId);\n    * }, async (taskId) => {\n    *   console.log('[BackgroundFetch] TIMEOUT', taskId);\n    *   if (taskId === 'my-custom-task') {\n    *     console.log('My custom task timed-out');\n    *   } else {\n    *     console.log('The default, periodic fetch task timed-out');\n    *   }\n    *   BackgroundFetch.finish(taskId);\n    * });\n    *\n    * // Execute an additional custom-task.\n    * BackgroundFetch.scheduleTask({\n    *   taskId: 'my-custom-task',  // <-- REQUIRED\n    *   delay: 10000,              // <-- REQUIRED\n    *   periodic: false            // <-- ONE-SHOT (default)\n    * })\n    * ```\n    */\n    static scheduleTask(config) {\n        return new Promise((resolve, reject) => {\n            if (typeof (config.delay) !== 'number') {\n                const delay = parseInt(config.delay, 10);\n                if (delay === NaN) {\n                    reject('[BackgroundFetch] TaskConfig.delay must be a number: ' + config.delay);\n                    return;\n                }\n                config.delay = delay;\n            }\n            return NativeModule.scheduleTask({ options: config }).then(() => {\n                resolve();\n            }).catch((error) => {\n                reject(error.message);\n            });\n        });\n    }\n    /**\n    * Start subscribing to fetch events.\n    *\n    * __Note:__ The inital call to [[configure]] *automatically* calls __`BackgroundFetch.start()`__\n    *\n    * ```javascript\n    *   async initBackgroundFetch() {\n    *     // Calling .configure() automatically starts the plugin.\n    *     const status = await BackgroundFetch.configure({\n    *       minimumFetchInterval: 15\n    *     }, async (taskId) => {  // <---------------- Event handler.\n    *       console.log('[BackgroundFetch] EVENT:', taskId);\n    *       BackgroundFetch.finish(taskId);\n    *     }, async (taskId) => {  // <---------------- Event timeout handler\n    *       console.log('[BackgroundFetch] TIMEOUT:', taskId);\n    *       // [REQUIRED] Signal to the OS that your work is complete.\n    *       BackgroundFetch.finish(taskId);\n    *     });\n    *   }\n    *\n    *   // Stop BackgroundFetch\n    *   onClickStop() {\n    *     BackgroundFetch.stop();\n    *   }\n    *\n    *   // Re-start BackgroundFetch\n    *   onClickStart() {\n    *     BackgroundFetch.start();\n    *   }\n    *\n    * ```\n    */\n    static start() {\n        return new Promise((resolve, reject) => {\n            NativeModule.start().then((result) => {\n                resolve(result.status);\n            }).catch((error) => {\n                reject(error.message);\n            });\n        });\n    }\n    /**\n    * Stop subscribing to fetch events.\n    *\n    * ```javascript\n    * // Stop everything.\n    * BackgroundFetch.stop();\n    * ```\n    *\n    * You may also provide an optional __`taskId`__ to stop a [[scheduleTask]]:\n    *\n    * ```javascript\n    * // Stop a particular task scheduled with BackgroundFetch.scheduleTask\n    * await BackgroundFetch.scheduleTask({\n    *   taskId: 'my-custom-task',\n    *   delay: 10000,\n    *   periodic: false\n    * });\n    * .\n    * .\n    * .\n    * BackgroundFetch.stop('my-custom-task');\n    * ```\n    */\n    static stop(taskId) {\n        return new Promise((resolve, reject) => {\n            NativeModule.stop({ taskId: taskId }).then(() => {\n                resolve();\n            }).catch((error) => {\n                reject(error.message);\n            });\n        });\n    }\n    /**\n    * You must execute `BackgroundFetch.finish(taskId)` within your fetch-callback to signal completion of your task.\n    *\n    * If you *fail* to call `.finish()`, the OS __will punish your app for poor behaviour and stop firing events__.\n    *\n    * ```javascript\n    * await BackgroundFetch.configure({\n    *   minimumFetchInterval: 15\n    * }, async (taskId) => {\n    *   console.log('[BackgroundFetch] EVENT', taskId);\n    *   // Always signal completion of your tasks.\n    *   BackgroundFetch.finish(taskId);\n    * }, async (taskId) => {\n    *   console.log('[BackgroundFetch] TIMEOUT', taskId);\n    *   // Always signal completion of your tasks.\n    *   BackgroundFetch.finish(taskId);\n    * });\n    * ```\n    */\n    static finish(taskId) {\n        return NativeModule.finish({ taskId: taskId });\n    }\n    /**\n    * Query the BackgroundFetch API status\n    *\n    * ```javascript\n    * // Checking BackgroundFetch status:\n    * const status = await BackgroundFetch.status();\n    *\n    * if (status !== BackgroundFetch.STATUS_AVAILABLE) {\n    *   // Uh-oh:  we have a problem:\n    *   if (status === BackgroundFetch.STATUS_DENIED) {\n    *     alert('The user explicitly disabled background behavior for this app or for the whole system.');\n    *   } else if (status === BackgroundFetch.STATUS_RESTRICTED) {\n    *     alert('Background updates are unavailable and the user cannot enable them again.')\n    *   }\n    * }\n    * ```\n    *\n    * | BackgroundFetchStatus              | Description                                     |\n    * |------------------------------------|-------------------------------------------------|\n    * | `BackgroundFetch.STATUS_RESTRICTED`  | Background fetch updates are unavailable and the user cannot enable them again. For example, this status can occur when parental controls are in effect for the current user. |\n    * | `BackgroundFetch.STATUS_DENIED`      | The user explicitly disabled background behavior for this app or for the whole system. |\n    * | `BackgroundFetch.STATUS_AVAILABLE`   | Background fetch is available and enabled.      |\n    */\n    static status() {\n        return new Promise((resolve, reject) => {\n            NativeModule.status().then((result) => {\n                resolve(result.status);\n            }).catch((error) => {\n                reject(error.message);\n            });\n        });\n    }\n}\nexport * from './definitions';\n//# sourceMappingURL=index.js.map"],"names":["registerPlugin"],"mappings":"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"}